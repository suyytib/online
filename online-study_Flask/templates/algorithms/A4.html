{% extends 'base.html' %}

{% block title %}
排序
{% endblock %}


{% block head %}
<!-- 加载注册用的js代码 -->
<script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.0.min.js"></script>
<script src="../../static/js/bootstrap.js"></script>
<script src="../../static/js/varlable_rule.js"></script>
<link rel="stylesheet" href="../../static/css/shuzi.css" />

<link rel="stylesheet" href="../../static/css/bootstart/bootstrap.min.css" />
<link rel="stylesheet" href="../../static/css/bootstart/bootstrap.css" />
<link rel="stylesheet" href="../../static/css/bootstart/bootstrap-grid.css" />
<link rel="stylesheet" href="../../static/css/bootstart/bootstrap-grid.rtl.css" />
{% endblock %}

{% block body%}
<div>
    <h4 style="text-align:center;">排序</h4>
    <a href="{{url_for('root')}}" class="btn btn-block btn-lg bg-white mt-4">返回</a>
    <ul class="nav nav-tabs" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home" type="button"
                role="tab" aria-controls="home" aria-selected="true">冒泡排序</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="profile-tab" data-bs-toggle="tab" data-bs-target="#profile" type="button"
                role="tab" aria-controls="profile" aria-selected="false">选择排序</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="contact-tab" data-bs-toggle="tab" data-bs-target="#contact" type="button"
                role="tab" aria-controls="contact" aria-selected="false">插入排序</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="contact-tab" data-bs-toggle="tab" data-bs-target="#contact1" type="button"
                role="tab" aria-controls="contact" aria-selected="false">快速排序</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="contact-tab" data-bs-toggle="tab" data-bs-target="#contact2" type="button"
                role="tab" aria-controls="contact" aria-selected="false">归并排序</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="contact-tab" data-bs-toggle="tab" data-bs-target="#contact3" type="button"
                role="tab" aria-controls="contact" aria-selected="false">桶排序</button>
        </li>
    </ul>
    <div class="tab-content" id="myTabContent">
        <div class="tab-pane fade  show active" id="home" role="tabpanel" aria-labelledby="home-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
冒泡排序的原理是：从左到右，相邻元素进行比较。每次比较一轮，就会找到序列中最大的一个或最小的一个。这个数就会从序列的最右边冒出来。

以从小到大排序为例，第一轮比较后，所有数中最大的那个数就会浮到最右边；第二轮比较后，所有数中第二大的那个数就会浮到倒数第二个位置……就这样一轮一轮地比较，最后实现从小到大排序。
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
        <div class="tab-pane fade" id="profile" role="tabpanel" aria-labelledby="profile-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
                        选择排序算法是通过遍历数组，选择出数组的最小或最大值，与指定位置交换数据，遍历完整个数组的所有位置就完成排序
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
        <div class="tab-pane fade" id="contact" role="tabpanel" aria-labelledby="contact-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
                        插入算法的基本原理就是在一串乱序的数字中，首先认为第一个数是有序的，然后从第二个数开始比较，每次比较都与前面排好序的部分由后往

前进行比较；
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
        <div class="tab-pane fade" id="contact1" role="tabpanel" aria-labelledby="contact-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
            首先对待排序序列进行一趟快速排序；
一趟排序下来之后，基准元素的左边都是比它小的元素，右边都是比它大的元素；
再对基准元素左边的序列进行快速排序，对右边也进行快速排序；
重复步骤2、3，直到序列排序完成
void quick_sort(int l, int r)//快速排序
{
//每次选一个数，以它为界划分左右区间并像归并一样返回
    if (l< r)//边界
    {     
        int i = l, j = r, x = a[l];
        while (i < j)//以x为界划分
        {
            while(i < j && a[j]>= x)
                j--; 
            if(i < j)
                a[i++] =a[j];
            while(i < j && a[i]< x)
                i++; 
            if(i < j)
                a[j--] = a[i];
        }
        a[i] = x;
        quick_sort( l, i - 1); //递归左区间
        quick_sort( i + 1, r);//递归右区间
    }
}
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
        <div class="tab-pane fade" id="contact2" role="tabpanel" aria-labelledby="contact-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
                        归并排序是用分治思想，分治模式在每一层递归上有三个步骤：
● 分解（Divide）：将n个元素分成个含n/2个元素的子序列。
● 解决（Conquer）：用合并排序法对两个子序列递归的排序。
● 合并（Combine）：合并两个已排序的子序列已得到排序结果。
void msort(int b,int e)//归并排序
{
    if(b==e)  
		return;
    int mid=(b+e)/2,i=b,j=mid+1,k=b;
    msort(b,mid),msort(mid+1,e);
    while(i<=mid&&j<=e)
    	if(a[i]<=a[j])
    		c[k++]=a[i++];
    	else
    		c[k++]=a[j++],ans+=mid-i+1;//统计答案
    while(i<=mid)
    	c[k++]=a[i++];
    while(j<=e)
    	c[k++]=a[j++];
    for(int l=b;l<=e;l++)
    	a[l]=c[l];
} 
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
        <div class="tab-pane fade" id="contact3" role="tabpanel" aria-labelledby="contact-tab">
            <blockquote class="blockquote left">
                <pre>
                    <code>
                        桶排序的思想就是把待排序的数尽量均匀地放到各个桶中，再对各个桶进行局部的排序，最后再按序将各个桶中的数输出，即可得到排好序的数。
                    </code>
                </pre>
            </blockquote>
            <blockquote class="blockquote right">
            </blockquote>
        </div>
    </div>
</div>
{% endblock %}